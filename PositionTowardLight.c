#pragma config(Sensor, S2,     lightSensor1,   sensorLightInactive)
#pragma config(Sensor, S3,     lightSensor2,   sensorLightInactive)
#pragma config(Motor,  motorA,          Rotation,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          Lid,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          LidAngle,      tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*

This is a program for a LEGO Mindstorm NXT 2.0 robot.  The robot is the control
system for an automatically regulated lunar greenhouse prototype, to be
deployed at the lunar poles.  On the lunar poles, as with any pole, there are
long periods of sunlight coming in nearly horizontally, but from any direction
around the horizon.  The other half of the orbital period is dark.

The robotic greenhouse needs to position itself in orientation to the sun, when
it's available, and gather light into the greenhouse by opening its lid, which
has a curved reflective inner surface.  If there is too much light, so that the
contents are in danger of overheating, the lid needs to close itself somewhat
to catch less sunlight.  On a real lunar robotic greenhouse, the front of the
greenhouse would have solar panels on it for collecting energy to supplementally
heat the contents or to provide power for the colony.

This program controls two motors to open the lid and to rotate the platform
that the greenhouse is sitting on.  It uses two light sensors on either side of
the greenhouse to determine whether the greenhouse is pointed towards the sun.
A third motor is used as a lid position sensor in read-only mode, coaxial with
the hinges on the lid.  The lid is opened by pulling a lever downward by
spooling a string onto a spindle, until the lid positioning sensor indicates
that the lid is opened as far as needed.  A significant difference in the
readout values of the light sensors causes the rotation motor to turn the
greenhouse so as to balance out the light readings.

There are only two functions, positioning the greenhouse towards the light and
opening, half opening and closing the lid, and it may have made sense to have
independent threads for those two activities, but the code is simple enough
this way.  It just uses a main loop with 100ms delay at the start of each loop
to let the motors run.  The motors run at low speed to keep things from
happening too fast.

*/



task main()
{
	// Wait a few seconds to let the user close the lid.  The lid needs to be
  //  closed at the beginning of the run to properly calibrate the lid angle
  //  position sensor.
	nxtDisplayBigTextLine( 3, "Close The Lid" );
	wait10Msec(500);

	// Make sure both of the motors are stopped and reset the angle indicator's
	//  opinion about the motor position so we can run it up to open the lid.
	motor[Rotation] = 0;
	motor[Lid] = 0;
	nMotorEncoder[LidAngle] = 0;

	while( true )
	{
		// Let everything started last loop run for 100ms.
		wait1Msec(100);

		// Display all of the sensor inputs, treating the third motor as a sensor.
		nxtDisplayBigTextLine( 1, "1: %d", SensorValue[lightSensor1] );
		nxtDisplayBigTextLine( 3, "2: %d", SensorValue[lightSensor2] );
		nxtDisplayBigTextLine( 5, "Lid: %d", nMotorEncoder[LidAngle] );
		
		// By default, stop the rotation motor, we'll turn it on briefly if needed.
		motor[Rotation] = 0;
		if (SensorValue[lightSensor1] - SensorValue[lightSensor2] > 10 )
		{
			// Turn one way, it's brighter over here
			motor[Rotation] = 20;
		}
		if (SensorValue[lightSensor2] - SensorValue[lightSensor1] > 10 )
		{
			// Turn the other way, it's brighter over there
			motor[Rotation] = -20;
		}

		// If there is enough light to warrant opening the lid to let it in, do that
		//  by checking whether the lid angle is not at or above the maximum, if so,
		//  run the lid motor forwards to open it a bit more.
		if ( SensorValue[lightSensor1] + SensorValue[lightSensor2] > 50 )
		{
			if( nMotorEncoder[LidAngle] > -65 )
			{
				motor[Lid] = 10;
			}
			else
			{
				motor[Lid] = 0;
			}
		}

		// Deal with overly bright light by closing to between -34 and -36 degrees.
		//  The lid walks up and down a bit if it overshoots the endpoints.  I'll
		//  try shortening the delay loop later.
		if ( SensorValue[lightSensor1] + SensorValue[lightSensor2] > 150 )
		{
			if( nMotorEncoder[LidAngle] > -36 )
			{
				motor[Lid] = 5;
			}
			else if( nMotorEncoder[LidAngle] < -34 )
			{
				motor[Lid] = -5;
			}
			else
			{
				motor[Lid] = 0;
			}
		}

		// Lastly, if the total light is too low, shut the lid if needed, as in the
		//  angle is more (negatively) than 5 degrees from where the 'closed'
		//  position was defined by the user to be.
		if ( SensorValue[lightSensor1] + SensorValue[lightSensor2] < 25 )
		{
			if( nMotorEncoder[LidAngle] < -5 )
			{
				motor[Lid] = -10;
			}
			else
			{
				motor[Lid] = 0
			}
		}
	}
}
